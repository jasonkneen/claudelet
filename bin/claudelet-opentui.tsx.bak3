#!/usr/bin/env bun

/**
 * Claudelet OpenTUI - Terminal User Interface Chat using OpenTUI + Claude Agent Loop
 *
 * Features:
 * - Fixed input bar with clean design
 * - Real-time thinking and tool indicators
 * - Smart message queue visualization
 * - @ file references with autocomplete
 * - All /commands supported
 *
 * Run with:
 *   bun run tui:opentui
 *   claudelet-opentui (if installed globally)
 */
import { execSync } from 'child_process';
import { EventEmitter } from 'events';
import * as fs from 'fs';
import * as fsp from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { createCliRenderer, type KeyEvent } from '@opentui/core';
import { createRoot, useKeyboard, useRenderer } from '@opentui/react';
import {
  createAuthManager,
  SmartMessageQueue,
  startAgentSession,
  FastModeCoordinator,
  MODEL_DISPLAY,
  getModelDisplayFromPreference,
  parseModelOverride,
  type AgentSessionHandle,
  type SubAgent,
  type SubAgentEvent,
  type OrchestrationContext
} from 'claude-agent-loop';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';

import { clearAuth, loadAuth, saveAuth } from '../src/auth-storage.js';
import { isMarkdown, renderMarkdown } from '../src/markdown-renderer.js';
import {
  completeSession,
  createSessionData,
  getActiveSessions,
  getSessionsDir,
  listSessions,
  loadSession,
  saveSession,
  type SessionData,
  type SessionSummary,
  type StoredMessage
} from '../src/session-storage.js';
import { sanitizeText } from '../src/env-sanitizer.js';
import { SecurityValidator } from '../src/security-validator.js';
import { AiToolsService } from './claudelet-ai-tools.js';
import { useBatchedState } from '../src/hooks/useBatchedState.js';
import {
  calculateAvailableRows,
  calculateVisibleMessages,
  type RenderableMessage
} from '../src/message-pagination.js';
import type {
  AppState,
  ContextChip,
  FileChip,
  FileExplorerEntry,
  FileExplorerNode,
  InputSegment,
  Message,
  Theme,
  ThinkingSession,
  ToolActivity
} from './opentui/types/index.js';
import {
  DEBUG,
  DEBUG_DIR,
  DEBUG_LOG,
  debugLog,
  ensureDebugDir,
  estimateTokenCount,
  extractAgentReferences,
  getAgentCompletions,
  getCommandCompletions,
  getPrintableCharFromKeyEvent,
  isModifyOtherKeysSequence,
  renderMultilineText,
  segmentsToDisplayString,
  SHIFTED_CHAR_MAP
} from './opentui/utils/index.js';
import { DEFAULT_THEMES, getInitialTheme, loadSavedThemeName, saveThemeName, THEME_CONFIG_FILE } from './opentui/themes/index.js';
import { handleApiKeyAuth, handleOAuthFlow, promptAuthMethod } from './opentui/auth/index.js';
import { extractToolActivity, formatThinkingChip, generateStartupBanner, LOGO } from './opentui/rendering/index.js';
import { ChatApp } from './opentui/components/index.js';

const MAX_THINKING_TOKENS = 16_000;
const TODOS_FILE = '.todos.md';
const MAX_FILE_SIZE = 500_000; // 500KB
const FILE_EXPLORER_PAGE_SIZE = 120;



/**
 * Read and parse the .todos.md file to extract current tasks
 */
async function readTaskList(): Promise<string> {
  try {
    const todoPath = path.resolve(process.cwd(), TODOS_FILE);
    const content = await fsp.readFile(todoPath, 'utf-8');

    if (!content.trim()) {
      return '[i] No tasks found in session';
    }

    return content;
  } catch (error) {
    return "[i] No task list found (Claude hasn't created tasks yet)";
  }
}

/**
 * Resolve a file reference and get its content
 */
async function resolveFileReference(filePath: string): Promise<string | null> {
  try {
    const resolved = path.resolve(process.cwd(), filePath);

    // Security: ensure file is within cwd
    const cwd = process.cwd();
    const normalized = path.normalize(resolved);
    if (!normalized.startsWith(path.normalize(cwd))) {
      return null;
    }

    const stat = await fsp.stat(resolved);
    if (!stat.isFile()) {
      return null;
    }

    if (stat.size > MAX_FILE_SIZE) {
      return null;
    }

    const content = await fsp.readFile(resolved, 'utf-8');
    return content;
  } catch {
    return null;
  }
}

/**
 * Convert input segments to message content (with file content embedded)
 */
async function segmentsToMessageContent(segments: InputSegment[]): Promise<string> {
  const parts = await Promise.all(
    segments.map(async (seg) => {
      if (seg.type === 'text') {
        return seg.text;
      } else if (seg.type === 'chip') {
        const content = await resolveFileReference(seg.chip.filePath);
        if (content) {
          return '\`\`\`' + seg.chip.label + '\\n' + content + '\\n\`\`\`';
        } else {
          return `[File not found: ${seg.chip.label}]`;
        }
      } else {
        // Context chips: include as metadata in message
        return `[Context: ${seg.context.isInclude ? 'INCLUDE' : 'EXCLUDE'} ${seg.context.label}]`;
      }
    })
  );
  return parts.join('');
}

/**
 * Get completions for @ file references
 */
async function getFileCompletions(prefix: string): Promise<string[]> {
  try {
    // Extract the path after @
    const match = prefix.match(/@(.*)$/);
    if (!match) {
      return [];
    }

    const filePath = match[1];
    let dirPath = '';
    let filter = '';

    // Determine directory and filter
    const lastSlash = filePath.lastIndexOf('/');
    if (lastSlash === -1) {
      // No slash, suggest files in current dir matching prefix
      dirPath = '.';
      filter = filePath;
    } else {
      // Has slash, suggest files in that directory
      dirPath = filePath.slice(0, lastSlash);
      filter = filePath.slice(lastSlash + 1);
    }

    const resolvedDir = path.resolve(process.cwd(), dirPath);

    // Security: ensure we don't escape cwd
    const normalized = path.normalize(resolvedDir);
    const cwd = path.normalize(process.cwd());

    if (!normalized.startsWith(cwd)) {
      return [];
    }

    // Read directory contents
    try {
      const entries = await fsp.readdir(resolvedDir, { withFileTypes: true });

      const filtered = entries.filter((entry) => entry.name.startsWith(filter));

      return filtered.map((entry) => {
        const name = entry.name;
        const suffix = entry.isDirectory() ? '/' : '';
        const fullPath =
          filePath.includes('/') ? filePath.slice(0, lastSlash + 1) + name + suffix : name + suffix;
        return '@' + fullPath;
      });
    } catch {
      return [];
    }
  } catch {
    return [];
  }
}

/**
 * Find completions for current input segments
 */
async function getCompletionsWithAgents(segments: InputSegment[], agents: SubAgent[]): Promise<string[]> {
  // Get the last text segment
  const lastSegment = segments[segments.length - 1];
  if (!lastSegment || lastSegment.type !== 'text') {
    return [];
  }

  const input = lastSegment.text;

  // Check if we're completing a command
  if (input.startsWith('/') && segments.length === 1) {
    return getCommandCompletions(input);
  }

  // Check if we're completing a file reference or agent reference
  if (input.includes('@')) {
    const lastAtIndex = input.lastIndexOf('@');
    // Check if this @ is after a space (new token) or at start
    if (lastAtIndex === 0 || input[lastAtIndex - 1] === ' ') {
      const afterAt = input.slice(lastAtIndex);
      const fileCompletions = await getFileCompletions(afterAt);

      // Add active agents to completion list at the TOP
      const agentCompletions = getAgentCompletions(afterAt, agents);

      // Agents first, then files
      return [...agentCompletions, ...fileCompletions];
    }
  }

  return [];
}

/**
 * Helper to switch model and update state/session
 */
async function switchModel(
  model: 'auto' | 'fast' | 'smart-sonnet' | 'smart-opus',
  session: AgentSessionHandle | null,
  updateState: (updates: Partial<AppState> | ((prev: AppState) => Partial<AppState>)) => void
): Promise<void> {
  try {
    if (session && model !== 'auto') {
      await session.setModel(model);
    }
    updateState((prev: AppState) => ({
      currentModel: model,
      messages: [
        ...prev.messages,
        { role: 'system', content: `[+] Switched to ${model}`, timestamp: new Date() }
      ]
    }));
  } catch (e) {
    updateState((prev: AppState) => ({
      messages: [
        ...prev.messages,
        {
          role: 'system',
          content: `[!] Failed to switch model: ${String(e)}`,
          timestamp: new Date()
        }
      ]
    }));
  }
}

// Render counter for debugging
let renderCount = 0;

/**
 * ToolActivityBoxes - Horizontal bordered boxes showing active tools
 * Each tool appears as a bordered box with 1 char spacing, wraps to fit
 * Similar styling to thinking/task indicators
 */

// Main entry point
async function main(): Promise<void> {
  // Initialize debug log at startup for fresh session
  if (DEBUG) {
    try {
      // Ensure debug directory exists with proper permissions
      await ensureDebugDir();
      await fsp.writeFile(DEBUG_LOG, `=== New Session: ${new Date().toISOString()} ===\n`);
      // Set restrictive permissions (user read/write only)
      await fsp.chmod(DEBUG_LOG, 0o600);
    } catch {
      // Ignore if can't write debug log
    }
  }

  debugLog('Main function starting...');
  let apiKey: string | null = null;
  let oauthToken: string | null = null;
  const authManager = createAuthManager();

  // Try to load existing auth
  debugLog('Loading stored auth...');
  const storedAuth = await loadAuth();

  if (storedAuth) {
    debugLog(`Stored auth found: ${storedAuth.type}`);
    if (storedAuth.type === 'api-key' && storedAuth.apiKey) {
      apiKey = storedAuth.apiKey;
      debugLog('Using API key from storage');
    } else if (storedAuth.type === 'oauth' && storedAuth.oauthTokens) {
      debugLog('Loading OAuth tokens...');
      authManager.loadAuthConfig({ oauthTokens: storedAuth.oauthTokens });
      const accessToken = await authManager.getOAuthAccessToken();
      if (accessToken) {
        oauthToken = accessToken;
        debugLog('OAuth token obtained');
        const newConfig = authManager.getAuthConfig();
        if (newConfig.oauthTokens) {
          await saveAuth({ type: 'oauth', oauthTokens: newConfig.oauthTokens });
        }
      } else {
        console.log('⚠️  Saved tokens expired. Please run claudelet to re-authenticate.');
        process.exit(1);
      }
    }
  } else {
    debugLog('No stored auth found');
  }

  // If no valid stored auth, prompt for authentication
  if (!apiKey && !oauthToken) {
    debugLog('No auth found, prompting user...');

    const authMethod = await promptAuthMethod();

    if (authMethod === '1') {
      // Anthropic Account (OAuth - console mode)
      const token = await handleOAuthFlow('console', authManager);
      if (token) {
        oauthToken = token;
        const config = authManager.getAuthConfig();
        if (config.oauthTokens) {
          await saveAuth({ type: 'oauth', oauthTokens: config.oauthTokens });
        }
      }
    } else if (authMethod === '2') {
      // Claude Max Subscription (OAuth - max mode)
      const token = await handleOAuthFlow('max', authManager);
      if (token) {
        oauthToken = token;
        const config = authManager.getAuthConfig();
        if (config.oauthTokens) {
          await saveAuth({ type: 'oauth', oauthTokens: config.oauthTokens });
        }
      }
    } else {
      // API Key (direct)
      apiKey = await handleApiKeyAuth();
      if (apiKey) {
        await saveAuth({ type: 'api-key', apiKey });
      }
    }

    if (!apiKey && !oauthToken) {
      console.error('\n❌ Authentication failed. Exiting.');
      process.exit(1);
    }

    console.log('\n✅ Authentication successful!');
  }

  // Check for active sessions to resume
  let resumeSession: SessionData | undefined;
  const startupTimings: Record<string, number> = {};
  const startTime = Date.now();
  debugLog('Checking for active sessions...');

  try {
    const activeSessions = await getActiveSessions(process.cwd());
    debugLog(`Found ${activeSessions.length} active session(s) in cwd`);

    if (activeSessions.length > 0) {
      // Auto-resume the last active session (most recently updated)
      const lastSession = activeSessions[0];
      resumeSession = (await loadSession(lastSession.filePath)) || undefined;
      if (resumeSession) {
        console.log(`\n↻ Resuming session ${resumeSession.sessionId.slice(0, 8)}... (${lastSession.messageCount} messages)`);
        debugLog(`Auto-resuming last session: ${resumeSession.sessionId}`);
      }
    }
  } catch (err) {
    debugLog(`Error checking active sessions: ${err}`);
    // Continue with new session
  }

  if (!resumeSession) {
    console.log('\n✨ Starting new session...');
  }

  // Log stdin state before creating the renderer
  // The renderer will handle setting up stdin (raw mode, listeners, etc.)
  debugLog(`stdin state before renderer: paused=${process.stdin.isPaused()}, isTTY=${process.stdin.isTTY}, isRaw=${(process.stdin as any).isRaw}`);

  // Create OpenTUI renderer - it handles stdin setup internally
  startupTimings.sessionSelection = Date.now() - startTime;
  debugLog(`Creating OpenTUI renderer... (${startupTimings.sessionSelection}ms since start)`);
  const rendererStart = Date.now();
  const renderer = await createCliRenderer({
    exitOnCtrlC: false, // We handle Ctrl+C manually
    useMouse: true, // Enable mouse tracking so scroll wheel doesn't trigger arrow keys
    useKittyKeyboard: null, // Disabled - was causing issues
    useAlternateScreen: true, // Enabled for correct scroll wheel capture
    useThread: false, // Disable native threading - might cause event loop blocking
    targetFps: 24, // Reduced from 30 to minimize screen redraws
    debounceDelay: 100 // Increased from 50 to batch more updates together
  });
  startupTimings.renderer = Date.now() - rendererStart;
  debugLog(`Renderer created in ${startupTimings.renderer}ms`);
  debugLog(`stdin state after renderer: paused=${process.stdin.isPaused()}, isTTY=${process.stdin.isTTY}, isRaw=${(process.stdin as any).isRaw}`);

  // Debug: Monitor render loop timing to find blocking
  let loopCount = 0;
  let lastLoopTime = Date.now();
  const originalLoop = (renderer as any).loop.bind(renderer);
  (renderer as any).loop = async function () {
    loopCount++;
    const now = Date.now();
    const gap = now - lastLoopTime;
    if (gap > 100 || loopCount <= 10) { // Log first 10 loops and any gaps > 100ms
      debugLog(`Loop #${loopCount}: gap=${gap}ms`);
    }
    lastLoopTime = now;
    const startTime = performance.now();
    const result = await originalLoop();
    const elapsed = performance.now() - startTime;
    if (elapsed > 50 || loopCount <= 10) { // Log slow loops
      debugLog(`Loop #${loopCount} took ${elapsed.toFixed(1)}ms`);
    }
    return result;
  };

  // Cleanup terminal on exit
  const cleanup = () => {
    debugLog('Cleaning up terminal...');
    try {
      // Restore terminal to normal mode
      process.stdin.setRawMode?.(false);

      // Reset terminal sequences
      process.stdout.write('\x1b[?1000l'); // Disable mouse tracking
      process.stdout.write('\x1b[?1002l');
      process.stdout.write('\x1b[?1003l');
      process.stdout.write('\x1b[?1006l');
      // Disable modifyOtherKeys / kitty keyboard protocol if enabled
      process.stdout.write('\x1b[>4m');
      process.stdout.write('\x1b[>0u');
      process.stdout.write('\x1b[?1049l'); // Exit alternate screen
      process.stdout.write('\x1b[?1l'); // Reset Application Cursor Keys (DECCKM)
      process.stdout.write('\x1b[?25h'); // Show cursor
      process.stdout.write('\x1b[0m'); // Reset colors
      process.stdout.write('\x1bc'); // Full terminal reset

      // Clear screen and position cursor
      process.stdout.write('\x1b[2J\x1b[H');
    } catch (err) {
      debugLog(`Cleanup error: ${err}`);
    }
  };

  let cleanupCalled = false;
  const safeCleanup = async () => {
    if (!cleanupCalled) {
      cleanupCalled = true;

      // Dispose AiToolsService to cleanup LSP servers and other resources
      try {
        const aiTools = state.aiTools;
        if (aiTools) {
          debugLog('Disposing AiToolsService...');
          await aiTools.dispose();
          debugLog('AiToolsService disposed');
        }
      } catch (err) {
        debugLog(`Error disposing AiToolsService: ${err}`);
      }

      cleanup();
    }
  };

  process.on('exit', () => {
    // Note: 'exit' event cannot be async, but we try cleanup anyway
    if (!cleanupCalled) {
      cleanupCalled = true;
      cleanup();
    }
  });

  process.on('SIGINT', async () => {
    debugLog('SIGINT received');
    await safeCleanup();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    debugLog('SIGTERM received');
    await safeCleanup();
    process.exit(0);
  });
  process.on('uncaughtException', async (err) => {
    debugLog(`Uncaught exception: ${err}`);
    await safeCleanup();
    process.exit(1);
  });

  // Render the app
  startupTimings.preRender = Date.now() - startTime;
  debugLog(`Rendering app... (${startupTimings.preRender}ms since start)`);
  debugLog(`stdin state before render: paused=${process.stdin.isPaused()}, destroyed=${process.stdin.destroyed}, readable=${process.stdin.readable}, isTTY=${process.stdin.isTTY}, isRaw=${(process.stdin as any).isRaw}`);
  debugLog(`⏱️ Startup: session=${startupTimings.sessionSelection}ms, renderer=${startupTimings.renderer}ms, total=${startupTimings.preRender}ms`);

  const root = createRoot(renderer);
  const authType: 'oauth' | 'api-key' = oauthToken ? 'oauth' : 'api-key';
  root.render(
    <ChatApp
      apiKey={apiKey || undefined}
      oauthToken={oauthToken || undefined}
      resumeSession={resumeSession}
      authType={authType}
    />
  );
  debugLog('App rendered (createRoot + render called)');

  // Start the continuous render loop - CRITICAL for preventing event loop blocking
  // Without this, the native Zig library causes ~19 second blocking during first renders
  renderer.start();
  debugLog('Renderer started');

  debugLog(`stdin state after render: paused=${process.stdin.isPaused()}, destroyed=${process.stdin.destroyed}, readable=${process.stdin.readable}, isTTY=${process.stdin.isTTY}, isRaw=${(process.stdin as any).isRaw}`);

  // Heartbeat to detect event loop blocking - logs every 2 seconds for first 30 seconds
  let heartbeatCount = 0;
  debugLog('Setting up heartbeat interval...');
  const heartbeatInterval = setInterval(() => {
    heartbeatCount++;
    debugLog(`Heartbeat ${heartbeatCount} (event loop alive)`);
    if (heartbeatCount >= 15) {
      clearInterval(heartbeatInterval);
      debugLog('Heartbeat monitoring complete');
    }
  }, 2000);
  debugLog('Heartbeat interval created, main() complete');

  // Test when event loop becomes free
  setImmediate(() => {
    debugLog('setImmediate fired - event loop free');
  });
  setTimeout(() => {
    debugLog('setTimeout(0) fired');
  }, 0);
  setTimeout(() => {
    debugLog('setTimeout(100) fired');
  }, 100);

  // Quick interval test - should fire every 500ms
  let quickCount = 0;
  const quickInterval = setInterval(() => {
    quickCount++;
    debugLog(`Quick interval ${quickCount} (500ms)`);
    if (quickCount >= 5) {
      clearInterval(quickInterval);
    }
  }, 500);
}

main().catch((err) => {
  debugLog(`Fatal error in main: ${err}`);
  console.error('Failed to start OpenTUI:', err);
  process.exit(1);
});
