import{EventEmitter as Y}from"events";var h={Q4_K_M:{file:"unsloth.Q4_K_M.gguf",size:986,quality:"Good",memory:1500,description:"Smallest & fastest. Recommended for most users."},Q5_K_M:{file:"unsloth.Q5_K_M.gguf",size:1130,quality:"Better",memory:1700,description:"Slightly better quality, moderate size."},Q8_0:{file:"unsloth.Q8_0.gguf",size:1650,quality:"High",memory:2200,description:"High quality for complex patches."},F16:{file:"unsloth.F16.gguf",size:3090,quality:"Maximum",memory:4e3,description:"Maximum quality. Requires more RAM."}},w="Q4_K_M",A="Kortix/FastApply-1.5B-v1.0_GGUF",_=".cluso/models/fast-apply",O=3e4,R=.1,I=8192,$="You are a coding assistant that applies code updates by REPLACING matching elements in-place. When given an update snippet, find the matching element in the original code and REPLACE it - do NOT insert a duplicate. Preserve all other code exactly. Return only the complete updated code.",B=`Apply the update to the code. If the update shows "FIND: X" and "REPLACE WITH: Y", find X in the code and replace it with Y. Do NOT insert duplicates - replace in-place.

<code>
{original_code}
</code>

<update>
{update_snippet}
</update>

Return the complete updated code with the change applied.`;function K(d,o){let e=B.replace("{original_code}",d).replace("{update_snippet}",o);return`<|im_start|>system
${$}<|im_end|>
<|im_start|>user
${e}<|im_end|>
<|im_start|>assistant
`}function k(d){if(!d||typeof d!="string")return console.log("[FastApply Parse] Invalid output type:",typeof d),null;console.log("[FastApply Parse] Raw output length:",d.length),console.log("[FastApply Parse] First 500 chars:",d.substring(0,500));let e=d.trim().replace(/<\|im_end\|>/g,"").replace(/<\|im_start\|>[\s\S]*$/g,"").trim(),t=[/^I\s/i,/^I['']/i,/^The\s/i,/^Here/i,/^This\s/i,/^To\s/i,/^You\s/i,/^Let\s?me/i,/^Sure/i,/^Certainly/i,/^Of course/i,/^Okay/i,/^First/i,/^Now\s/i,/^Below/i,/^Great/i,/^Happy/i,/^In\s/i,/^Note/i];for(let a of t)if(a.test(e))return console.log("[FastApply Parse] \u274C Output STARTS with prose - rejecting entirely"),console.log("[FastApply Parse] First 100 chars:",e.substring(0,100)),null;let s=/^(<[\w!]|import\s|export\s|const\s|let\s|var\s|function\s|class\s|interface\s|type\s|enum\s|\/\/|\/\*|\{|#|package\s|using\s|public\s|private\s|protected\s|def\s|async\s|await\s|\s)/;if(e.length>0&&s.test(e))return console.log("[FastApply Parse] \u2705 Output recognized as code"),e;let n=e.match(/```[\w]*\n?([\s\S]*?)\n?```/);if(n)return console.log("[FastApply Parse] \u2705 Found code in markdown fences"),n[1].trim();let i=e.match(/<updated[-_]?code>([\s\S]*?)<\/updated[-_]?code>/i);return i?(console.log("[FastApply Parse] \u2705 Found legacy <updated-code> tags"),i[1].trim()):e.length>50?(console.log("[FastApply Parse] \u26A0\uFE0F Using output as-is (>50 chars, not prose)"),e):(console.log("[FastApply Parse] \u274C Could not parse output - too short or unrecognized"),null)}import*as f from"fs";import*as D from"path";import*as F from"os";import{EventEmitter as G}from"events";import*as l from"fs";import*as V from"path";import*as C from"os";import*as W from"https";import*as Q from"http";var M=class extends G{constructor(e){super();this.currentDownload=null;this.storageDir=e}getModelPath(e){let t=h[e];return V.join(this.storageDir,t.file)}async isDownloaded(e){let t=this.getModelPath(e);try{await l.promises.access(t,l.constants.R_OK);let s=await l.promises.stat(t),n=h[e].size*1024*1024;return s.size>=n*.95}catch{return!1}}async getDownloadedModels(){let e=[];for(let t of Object.keys(h))await this.isDownloaded(t)&&e.push(t);return e}async download(e){if(console.log("[Downloader] Download called for variant:",e),this.currentDownload)throw console.log("[Downloader] Already downloading:",this.currentDownload.variant),new Error(`Already downloading ${this.currentDownload.variant}`);let t=h[e];if(!t)throw console.error("[Downloader] Unknown model variant:",e),new Error(`Unknown model variant: ${e}`);let s=this.getModelPath(e),n=s+".tmp";console.log("[Downloader] Model path:",s),console.log("[Downloader] Temp path:",n),console.log("[Downloader] Creating storage dir:",this.storageDir),await l.promises.mkdir(this.storageDir,{recursive:!0});let i=t.size*1024*1024*1.1;await this.checkDiskSpace(i);let a=`https://huggingface.co/${A}/resolve/main/${t.file}`;console.log("[Downloader] Download URL:",a);let g=new AbortController;this.currentDownload={variant:e,controller:g};try{return console.log("[Downloader] Starting download..."),await this.downloadFile(a,n,e,g.signal),console.log("[Downloader] Download complete, renaming temp file..."),await l.promises.rename(n,s),await this.validateDownloadedFile(s,t),console.log("[Downloader] Model saved to:",s),this.emit("complete",s),s}catch(c){if(console.error("[Downloader] Download error:",c),c instanceof Error&&c.name!=="AbortError")try{await l.promises.unlink(n)}catch{}throw this.emit("error",c instanceof Error?c:new Error(String(c))),c}finally{this.currentDownload=null}}cancel(){this.currentDownload&&this.currentDownload.controller.abort()}async delete(e){let t=this.getModelPath(e);try{await l.promises.unlink(t)}catch(s){if(s.code!=="ENOENT")throw s}}async downloadFile(e,t,s,n){return console.log("[Downloader] downloadFile called:",{url:e,destPath:t,variant:s}),new Promise((i,a)=>{let g=e.startsWith("https")?W:Q;console.log("[Downloader] Using protocol:",e.startsWith("https")?"https":"http");let c=g.get(e,r=>{if(console.log("[Downloader] Response received:",{statusCode:r.statusCode,headers:{"content-length":r.headers["content-length"],"content-type":r.headers["content-type"],location:r.headers.location}}),r.statusCode===301||r.statusCode===302){let p=r.headers.location;if(console.log("[Downloader] Redirecting to:",p),p){this.downloadFile(p,t,s,n).then(i).catch(a);return}}if(r.statusCode!==200){console.error("[Downloader] Bad status code:",r.statusCode),a(new Error(`Download failed with status ${r.statusCode}`));return}let u=parseInt(r.headers["content-length"]||"0",10),m=0,S=Date.now(),L=0,y=l.createWriteStream(t);n.addEventListener("abort",()=>{c.destroy(),y.close(),a(new Error("Download cancelled"))}),r.on("data",p=>{m+=p.length,y.write(p);let b=Date.now(),T=b-S;if(T>=500){let P=(m-L)/T*1e3,N=u-m,U=P>0?N/P:0,q={variant:s,downloaded:m,total:u,percent:u>0?Math.round(m/u*100):0,speed:P,eta:U};this.emit("progress",q),S=b,L=m}}),r.on("end",()=>{y.end(()=>{let p={variant:s,downloaded:m,total:u,percent:100,speed:0,eta:0};this.emit("progress",p),i()})}),r.on("error",p=>{y.close(),a(p)}),y.on("error",p=>{a(p)})});c.on("error",r=>{a(r)})})}async checkDiskSpace(e){let t=l.promises.statfs;try{if(typeof t=="function"){let n=await t(this.storageDir),i=Number(n.bavail)*Number(n.bsize);if(i<e)throw new Error(`Not enough disk space. Required: ${Math.round(e/(1024*1024))} MB, available: ${Math.round(i/(1024*1024))} MB`);return}}catch(n){console.warn("[Downloader] statfs check failed, falling back to freemem():",n)}let s=C.freemem();if(s<e)throw new Error(`Not enough memory-reported free space. Required: ${Math.round(e/(1024*1024))} MB, available: ${Math.round(s/(1024*1024))} MB`)}async validateDownloadedFile(e,t){let s=t.size*1024*1024,n=await l.promises.stat(e);if(!(n.size>=s*.99&&n.size<=s*1.01)){try{await l.promises.unlink(e)}catch{}throw new Error(`Downloaded file size mismatch for ${t.file}. Expected ~${t.size} MB, got ${Math.round(n.size/(1024*1024))} MB`)}}};import{EventEmitter as H}from"events";var z=new Function("specifier","return import(specifier)"),v=class extends H{constructor(){super(...arguments);this.llama=null;this.model=null;this.context=null;this.modelPath=null;this.loading=!1;this.applyMutex=Promise.resolve()}isLoaded(){return this.model!==null&&this.context!==null}getLoadedModelPath(){return this.modelPath}async load(e){if(this.loading)throw new Error("Already loading a model");if(!(this.modelPath===e&&this.isLoaded())){this.isLoaded()&&await this.unload(),this.loading=!0;try{let{getLlama:t}=await z("node-llama-cpp");this.llama||(this.llama=await t()),console.log(`[FastApply] Loading model from ${e}`),this.model=await this.llama.loadModel({modelPath:e}),this.context=await this.model.createContext({contextSize:8192}),this.modelPath=e,this.emit("loaded"),console.log("[FastApply] Model loaded successfully")}catch(t){throw this.emit("error",t instanceof Error?t:new Error(String(t))),t}finally{this.loading=!1}}}async unload(){this.context&&(await this.context.dispose(),this.context=null),this.model&&(await this.model.dispose(),this.model=null),this.modelPath=null,this.emit("unloaded"),console.log("[FastApply] Model unloaded")}async apply(e,t){return this.withApplyLock(async()=>{if(!this.isLoaded()||!this.context||!this.model)return{success:!1,error:"Model not loaded"};let s=Date.now(),n=null,i=null;try{let a=K(e,t);console.log("[FastApply] Prompt built"),console.log("[FastApply] Original code length:",e.length),console.log("[FastApply] Update snippet length:",t.length),console.log("[FastApply] Total prompt length:",a.length),e.length>1e4&&console.warn("[FastApply] \u26A0\uFE0F Large input detected - inference may be slow"),console.log("[FastApply] Getting sequence...");let{LlamaChatSession:g}=await z("node-llama-cpp");i=this.context.getSequence(),console.log("[FastApply] Sequence acquired, creating session..."),n=new g({contextSequence:i}),console.log("[FastApply] Running inference...");let c=n.prompt(a,{maxTokens:I,temperature:R}),r=await this.runWithTimeout(c),u=Date.now()-s;console.log(`[FastApply] Inference completed in ${u}ms`);let m=k(r);return console.log("[FastApply] Output parsed:",m?"success":"failed"),m?{success:!0,code:m,durationMs:u}:(console.log("[FastApply] Raw output:",typeof r=="string"?r.substring(0,200):String(r)),{success:!1,error:"Failed to parse model output",durationMs:u})}catch(a){let g=Date.now()-s;return console.error("[FastApply] Inference error:",a),{success:!1,error:a instanceof Error?a.message:String(a),durationMs:g}}finally{if(n)try{await n.dispose?.(),console.log("[FastApply] Session disposed")}catch(a){console.warn("[FastApply] Session dispose error:",a)}if(i)try{await i.dispose?.(),console.log("[FastApply] Sequence disposed")}catch(a){console.warn("[FastApply] Sequence dispose error:",a)}}})}async withApplyLock(e){let t,s=this.applyMutex;this.applyMutex=new Promise(n=>{t=n}),await s;try{return await e()}finally{t()}}async runWithTimeout(e){let t=null;try{let s=new Promise((n,i)=>{t=setTimeout(()=>i(new Error("Inference timeout")),O)});return await Promise.race([e,s])}finally{t&&clearTimeout(t)}}async dispose(){await this.unload(),this.llama&&(this.llama=null)}};var E=class{constructor(o){this.activeModel=null;this.enabled=!1;o?this.storageDir=o.startsWith("~")?D.join(F.homedir(),o.slice(1)):o:this.storageDir=D.join(F.homedir(),_),this.configPath=D.join(this.storageDir,"config.json"),this.downloader=new M(this.storageDir),this.engine=new v,this.loadConfig()}getDownloader(){return this.downloader}getEngine(){return this.engine}getStorageDir(){return this.storageDir}async listModels(){let o=await this.downloader.getDownloadedModels();return Object.keys(h).map(e=>{let t=h[e],s=o.includes(e);return{variant:e,file:t.file,size:t.size,quality:t.quality,memory:t.memory,description:t.description,downloaded:s,path:s?this.downloader.getModelPath(e):void 0}})}getActiveModel(){return this.activeModel}async setActiveModel(o,e=!0){if(!h[o])throw new Error(`Unknown model variant: ${o}`);if(!await this.downloader.isDownloaded(o))if(e)await this.downloader.download(o);else throw new Error(`Model ${o} is not downloaded`);if(this.engine.isLoaded()){let s=this.engine.getLoadedModelPath(),n=this.downloader.getModelPath(o);s!==n&&await this.engine.unload()}this.activeModel=o,this.saveConfig()}async ensureLoaded(){if(!this.activeModel)if(await this.downloader.isDownloaded(w))this.activeModel=w;else throw new Error("No model available. Please download a model first.");if(!this.engine.isLoaded()){let o=this.downloader.getModelPath(this.activeModel);await this.engine.load(o)}}async getStatus(){let o=await this.downloader.getDownloadedModels();return{ready:this.engine.isLoaded(),activeModel:this.activeModel,modelLoaded:this.engine.isLoaded(),downloadedModels:o,storageDir:this.storageDir}}async download(o=w){return this.downloader.download(o)}cancelDownload(){this.downloader.cancel()}async deleteModel(o){this.activeModel===o&&this.engine.isLoaded()&&await this.engine.unload(),this.activeModel===o&&(this.activeModel=null,this.saveConfig()),await this.downloader.delete(o)}async unload(){await this.engine.unload()}async dispose(){await this.engine.dispose()}loadConfig(){try{let o=f.readFileSync(this.configPath,"utf-8"),e=JSON.parse(o);e.activeModel&&h[e.activeModel]&&(this.activeModel=e.activeModel),typeof e.enabled=="boolean"&&(this.enabled=e.enabled)}catch{}}saveConfig(){try{f.mkdirSync(this.storageDir,{recursive:!0});let o={activeModel:this.activeModel,enabled:this.enabled,lastUpdated:new Date().toISOString()};f.writeFileSync(this.configPath,JSON.stringify(o,null,2))}catch(o){console.warn("[FastApply] Failed to save config:",o)}}isEnabled(){return this.enabled}setEnabled(o){this.enabled=o,this.saveConfig()}};var x=class extends Y{constructor(o){super(),this.options={defaultModel:w,autoDownload:!1,...o},this.manager=new E(o?.storageDir);let e=this.manager.getDownloader();e.on("progress",s=>{this.emit("download:progress",s)}),e.on("complete",s=>{this.emit("download:complete",s)}),e.on("error",s=>{this.emit("download:error",s)});let t=this.manager.getEngine();t.on("loaded",()=>{this.emit("model:loaded")}),t.on("unloaded",()=>{this.emit("model:unloaded")})}async listModels(){return this.manager.listModels()}getActiveModel(){return this.manager.getActiveModel()}async setActiveModel(o){await this.manager.setActiveModel(o,this.options.autoDownload)}isEnabled(){return this.manager.isEnabled()}setEnabled(o){this.manager.setEnabled(o)}async download(o){return this.manager.download(o||this.options.defaultModel)}cancelDownload(){this.manager.cancelDownload()}async deleteModel(o){await this.manager.deleteModel(o)}async apply(o,e){try{return await this.manager.ensureLoaded(),await this.manager.getEngine().apply(o,e)}catch(t){return{success:!1,error:t instanceof Error?t.message:String(t)}}}async getStatus(){return this.manager.getStatus()}async load(){await this.manager.ensureLoaded()}async unload(){await this.manager.unload()}async dispose(){await this.manager.dispose()}};export{w as DEFAULT_MODEL,x as FastApply,h as MODELS,A as MODEL_REPO};
