var k=Object.defineProperty;var x=(o,e)=>{for(var t in e)k(o,t,{get:e[t],enumerable:!0})};import{Buffer as l}from"node:buffer";var J=new TextEncoder,f=new TextDecoder,N=2**32;function A(o){let e=o;return e instanceof Uint8Array&&(e=f.decode(e)),e}var u=o=>l.from(o).toString("base64url");var d=o=>new Uint8Array(l.from(A(o),"base64url"));var a={};x(a,{decode:()=>_,encode:()=>T});var T=u,_=d;function b(o){let e=new Uint8Array(o);return crypto.getRandomValues(e),a.encode(e)}async function C(o,e){if(e==="plain")return o;let r=new TextEncoder().encode(o),n=await crypto.subtle.digest("SHA-256",r);return a.encode(new Uint8Array(n))}async function m(o=64){if(o<43||o>128)throw new Error("Code verifier length must be between 43 and 128 characters");let e=b(o),t=await C(e,"S256");return{verifier:e,challenge:t,method:"S256"}}var O="9d1c250a-e61b-44d9-88ed-5944d1962f5e",I="https://claude.ai/oauth/authorize",R="https://console.anthropic.com/oauth/authorize",y="https://console.anthropic.com/v1/oauth/token",g="https://console.anthropic.com/oauth/code/callback",P="https://api.anthropic.com/api/oauth/claude_cli/create_api_key",S="org:create_api_key user:profile user:inference",v=3e4,U=5*60*1e3;function K(){let o=new Uint8Array(32);return crypto.getRandomValues(o),Array.from(o,e=>e.toString(16).padStart(2,"0")).join("")}function w(o){if(typeof o!="object"||o===null)throw new Error("Invalid OAuth response: expected object");let e=o;if(typeof e.access_token!="string"||!e.access_token)throw new Error("Invalid OAuth response: missing or invalid access_token");if(typeof e.refresh_token!="string"||!e.refresh_token)throw new Error("Invalid OAuth response: missing or invalid refresh_token");if(typeof e.expires_in!="number"||e.expires_in<=0)throw new Error("Invalid OAuth response: missing or invalid expires_in");return{access_token:e.access_token,refresh_token:e.refresh_token,expires_in:e.expires_in}}function M(o){if(typeof o!="object"||o===null)throw new Error("Invalid API key response: expected object");let e=o;if(typeof e.raw_key!="string"||!e.raw_key)throw new Error("Invalid API key response: missing or invalid raw_key");return{raw_key:e.raw_key}}var h=class{clientId;openUrl;timeoutMs;tokenExpirationBufferMs;constructor(e={}){if(this.clientId=e.clientId?.trim()||O,this.openUrl=e.openUrl,this.timeoutMs=e.timeoutMs??v,this.tokenExpirationBufferMs=e.tokenExpirationBufferMs??U,!this.clientId)throw new Error("Client ID must not be empty")}async generatePKCEChallenge(){let e=await m();return{challenge:e.challenge,verifier:e.verifier}}getAuthorizationUrl(e,t,r){let n=e==="max"?I:R,s=new URLSearchParams({code:"true",client_id:this.clientId,response_type:"code",redirect_uri:g,scope:S,code_challenge:t.challenge,code_challenge_method:"S256",state:r});return`${n}?${s.toString()}`}async fetchWithTimeout(e,t,r){let n=new AbortController,s=setTimeout(()=>n.abort(),this.timeoutMs);try{return await fetch(e,{...t,signal:n.signal})}catch(i){throw i instanceof Error?i.name==="AbortError"?new Error(`${r} timed out after ${this.timeoutMs}ms`):i.message.includes("Failed to fetch")||i.message.includes("fetch")?new Error(`${r} failed: Unable to connect. Check your internet connection.`):new Error(`${r} failed: ${i.message}`):i}finally{clearTimeout(s)}}async handleHttpError(e,t){let r="";try{r=await e.text(),r.length>200&&(r=r.substring(0,200)+"...")}catch{r="(unable to read error response)"}let s={400:"Invalid request parameters",401:"Authentication failed",403:"Access denied",404:"OAuth endpoint not found",429:"Too many requests - please try again later",500:"OAuth server error",502:"OAuth server temporarily unavailable",503:"OAuth server temporarily unavailable"}[e.status]||e.statusText;throw new Error(`${t} failed (${e.status}): ${s}`)}async parseJsonResponse(e,t,r){let n;try{n=await e.json()}catch{throw new Error(`${r} failed: Invalid JSON response from server`)}try{return t(n)}catch(s){throw s instanceof Error?new Error(`${r} failed: ${s.message}`):s}}async startLogin(e="console"){let t=await this.generatePKCEChallenge(),r=K(),n=this.getAuthorizationUrl(e,t,r);if(this.openUrl)try{await this.openUrl(n)}catch{}return{authUrl:n,verifier:t.verifier,state:r}}async exchangeCodeForTokens(e,t,r){let[n,s]=e.split("#");if(s&&s!==r)throw new Error("State mismatch: The callback state does not match the expected state. This may indicate a CSRF attack or an expired session.");if(!n?.trim())throw new Error("Invalid authorization code: code is empty");let i={code:n,grant_type:"authorization_code",client_id:this.clientId,redirect_uri:g,code_verifier:t};s&&(i.state=s);let c=await this.fetchWithTimeout(y,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)},"Token exchange");c.ok||await this.handleHttpError(c,"Token exchange");let p=await this.parseJsonResponse(c,w,"Token exchange");return{type:"oauth",refresh:p.refresh_token,access:p.access_token,expires:Date.now()+p.expires_in*1e3}}async createApiKey(e){if(!e?.trim())throw new Error("Access token is required to create API key");let t=await this.fetchWithTimeout(P,{method:"POST",headers:{"Content-Type":"application/json",authorization:`Bearer ${e}`}},"API key creation");return t.ok||await this.handleHttpError(t,"API key creation"),(await this.parseJsonResponse(t,M,"API key creation")).raw_key}async completeLogin(e,t,r,n=!1){if(!e||typeof e!="string")throw new Error("Authorization code is required");if(!t||typeof t!="string")throw new Error("PKCE verifier is required");if(!r||typeof r!="string")throw new Error("State parameter is required for CSRF protection");let s=await this.exchangeCodeForTokens(e.trim(),t.trim(),r.trim());if(n){let i=await this.createApiKey(s.access);return{tokens:s,apiKey:i}}return{tokens:s}}async refreshAccessToken(e){if(!e||typeof e!="string")throw new Error("Refresh token is required");let t=await this.fetchWithTimeout(y,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({grant_type:"refresh_token",refresh_token:e.trim(),client_id:this.clientId})},"Token refresh");t.ok||await this.handleHttpError(t,"Token refresh");let r=await this.parseJsonResponse(t,w,"Token refresh");return{type:"oauth",refresh:r.refresh_token,access:r.access_token,expires:Date.now()+r.expires_in*1e3}}isTokenExpired(e){return e.expires<Date.now()+this.tokenExpirationBufferMs}async getValidAccessToken(e){if(this.isTokenExpired(e)){let t=await this.refreshAccessToken(e.refresh);return{accessToken:t.access,tokens:t}}return{accessToken:e.access}}};export{h as AnthropicOAuthClient};
